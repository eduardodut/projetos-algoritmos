---
title: "R Notebook"
output: html_notebook
---

Atividades da 1a entrega:

a) Realizar a leitura do arquivo de entrada, armazenando os dados dos contratos (0,5 ponto) (Data de entrega: 16/06):
    1. Em um vetor de objetos do tipo contrato; e
    2. Em uma matriz, indexada pelo fornecedor, pelo mês de início e pelo mês de fim do contrato, onde cada elemento armazena o valor do contrato respectivo.


```{r message=FALSE, warning=FALSE}
start_time <- Sys.time()
library(magrittr)
library(readr)

parametro <- read.table(
  file = "Dados/entrada.txt",
  header = FALSE,
  nrows = 1,
  col.names = c("n", "m", "t")
)
attach(parametro)

entrada_matricial <- array(dim = c(m, #número do fornecedor
                                   n, #mês_inicial
                                   n))#mês_final
entrada_vetorizada <- list()
                               
contrato <- setRefClass("contrato", fields=list(empresa = "numeric", mes_inicial="numeric",mes_final="numeric", valor="numeric"))


arquivo_em_linhas <-
  read_lines(
    file = "Dados/entrada.txt",
    skip = 0,
    skip_empty_rows = FALSE,
    n_max = -1L,
    locale = default_locale(),
    na = character(),
    progress = show_progress()
  )



i=0
for (i in 2:length(arquivo_em_linhas)) {
  
 dados =  strsplit(arquivo_em_linhas[i], " ")[[1]]
  empresa = strtoi(dados[1])
  mes_inicial = strtoi(dados[2])
  mes_final= strtoi(dados[3])
  valor = as.double(dados[4])

  entrada_matricial[empresa, mes_inicial, mes_final] = valor
  
  c <- contrato(empresa = empresa, mes_inicial = mes_inicial, mes_final = mes_final, valor = valor)
  
  
  entrada_vetorizada<-append(entrada_vetorizada, contrato)
  #entrada_vetorizada[i-1] <- contrato
  #entrada_vetorizada[1]$dim$valor
 }




end_time <- Sys.time()

end_time - start_time
```


```{r}



```

b) Explicar qual das duas maneiras de armazenamento dos dados é mais eficiente, em relação ao consumo de memória, tanto em termos assintóticos quanto em termos de absolutos. (Data de entrega: 18/06) (0,5 ponto)


```{r}
m=100
n=120
#denso
n_posicoes_entrada_vetorizada = 4*        #o número de dados por contrato (empresa, mês inicial, mês final e valor) 
                                m*        #numéro de empresas
                                n*(n+1)/2 # soma da progressão aritmética dos contratos por empresas

#esparso
n_posicões_entrada_matricial = m*        #numéro de empresas
                                n*(n+n)/2# m*n^2 ou, a soma de 120 até 120, (ao invés de 120 até 1, pois a posição é alocada mesmo que não haja contrato para ocupá-la)

n_posicoes_entrada_vetorizada
n_posicões_entrada_matricial
```

c) Implementar o método de ordenação **Insertion Sort** para ordenar o vetor de objetos do tipo contrato. Criar um clone do vetor (simplesmente para não alterar a organização original dos dados) e aplicar o método de ordenação, exibindo ao final o tempo total de execução da ordenação. (Data de entrega: 16/06) (1,0 ponto)

```{r}
insertion_sort <- function(A){
     
  for (i in 2:dim(A)[1]) {
    key <- A[i] 

    j <- i - 1 
    while (j > 0 && A[j] > key["valor"]) {
      A[(j + 1),] <- A[j,]
    
      j <- j - 1 
    }
    A[(j + 1),] <- key
  }
  A
} 
amostras <- sample(1:72600,7000)
start_time <- Sys.time()


saida <- insertion_sort(entrada_vetorizada[[]])
end_time <- Sys.time()
  #entrada_vetorizada[[1]]$field("mes_inicial")
duracao_insertion_sort <- end_time - start_time
duracao_insertion_sort
entrada_vetorizada[1:10]

dim(entrada_vetorizada[0])
```
d) Apresentar a complexidade da função descrita no item anterior, fazendo uso de notação assintótica e tendo como parâmetros somente a quantidade n de meses e a quantidade m de fornecedores. (Data de entrega: 18/06) (0,5 ponto)

Θ(m²n⁴)

e) Implementar o método de ordenação Mergesort para ordenar o vetor de objetos do tipo contrato. Criar um clone do vetor e aplicar o método de ordenação, exibindo ao final o tempo total de execução da ordenação. (Data de entrega: 23/06) (1,0 ponto)
f) Apresentar a complexidade da função descrita no item anterior, fazendo uso de notação assintótica e tendo como parâmetros somente a quantidade n de meses e a quantidade m de fornecedores. (Data de entrega: 23/06) (0,5 ponto)
g) Implementar o método de ordenação Heapsort para ordenar o vetor de objetos do tipo contrato. Criar um clone do vetor e aplicar o método de ordenação, exibindo ao final o tempo total de execução da ordenação. (Data de entrega: 23/06) (1,0 ponto)
h) Apresentar a complexidade da função descrita no item anterior, fazendo uso de notação assintótica e tendo como parâmetros somente a quantidade n de meses e a quantidade m de fornecedores. (Data de entrega: 23/06) (0,5 ponto)
i) Implementar o método de ordenação Quicksort para ordenar o vetor de objetos do tipo contrato. Criar um clone do vetor e aplicar o método de ordenação, exibindo ao final o tempo total de execução da ordenação. (Data de entrega: 23/06) (1,0 ponto)
j) Apresentar a complexidade da função descrita no item anterior, fazendo uso de notação assintótica e tendo como parâmetros somente a quantidade n de meses e a quantidade m de fornecedores. (Data de entrega: 23/06) (0,5 ponto)
k) Baseando-se nas ideias dos algoritmos apresentados, criar um método de ordenação que, entretanto, explore as regras de formação de preços de contratos de um fornecedor (expressas na matriz de contratos), para realizar a ordenação dos contratos pelo valor, exibindo ao final o tempo total de execução da ordenação. (Data de entrega: 25/06) (2,0 pontos)
l) Apresentar a complexidade da função descrita no item anterior, fazendo uso de notação assintótica e tendo como parâmetros somente a quantidade n de meses e a quantidade m de fornecedores. (Data de entrega: 25/06) (1,0 ponto)



```{r}


```

